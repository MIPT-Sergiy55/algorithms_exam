# DP продолжение.
***
### Задача о рюкзаке
![img_7.png](img_7.png)
```c++
dp[i][x]; // макс. сумм. стоимость предметов если есть только первые i предметов,
// а суммарный вес ровно x
// -inf если нельзя набрать такой вес
```
```c++
dp[0][0] = 0;
dp[0][>0] = -inf;
```
```c++
dp[i + 1][x] = max(dp[i][x], dp[i][x - w[i + 1]] + c[i + 1]);
```
```c++
for(int i = 0; i < n; ++i)
    for(int x = 0; x < W; ++x)
        dp[i][x] = ...;
```
```c++
x = {0, 1, 2,...,W};
max(dp[n][x]);
```
> O(n * W) времени и O(W) памяти  
### Второе решение
```c++
dp[i][y]; // - минимальная сумма предметов, если доступны первые i,
// и нужно взять предметов суммарной стоимости y
```
```c++
--||--
```
```c++
dp[i + 1][y] = min(dp[i][y], dp[i][y - c[i + 1]] + w[i + 1]);
```
```c++
--||--
```
> O(n * C) времени и O(C) памяти
### Восстановление ответа
Хотим знать, какие предметы нужно взять, чтобы набрать макс вес
> Будем дополнительно хранить: ``p[i][x] = 0``, если значение ``dp[i][x]`` достигается без взятия i-го предмета, ``p[i][x] = 1`` иначе.  
> Ответ dp[n][x] = 0 => dp[n - 1][x] | = 1 => dp[n - 1][x - w[n]]  
> Приходится использовать O(n * W) памяти  
> Но используя корневую декомпозицию можно уменьшить асимптотику

### Почему не работает жадный алгоритм?
Наивный: брать предмет макс. стоимости, пока он вмещается в рюкзак
> Контр пример -  c1 = 2, w = 100, ... ci = 1, wi = 1

Менее наивный: брать предмет макс плотности
> Контр пример - надеюсь, что придумаю на экзе

Пока неизвестно ни одного алгоритма, который бы работал за Poly(|input|)
> n, W + n пар (wi, ci) = log n + log W + n(log W + log C_max) - длина входа =>  
> n*W будет экспонентой от длины входа  
> NP трудная задача
### Задача о числах Фибоначчи
![img_8.png](img_8.png)
> Решение через возведение матрицы в степень:

![img_9.png](img_9.png)

 > Быстрое возведение матрицы в степень: 

![img_11.png](img_11.png)

