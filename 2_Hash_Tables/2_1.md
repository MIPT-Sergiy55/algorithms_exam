# Хеш-таблицы
***
> Деревья поиска:
> - insert
> - erase
> - find  
> За O(log n)

> Хеш-таблицы:
>- insert
>- erase
>- find  
> За O(1)*  
> \* - амортизированное и усредненное
 
### Хеш-таблицы цепочками
U - универсум, все ключи - его эл-ты.  
``h : U -> {0, 1, ..., m - 1}``  
Массив длины m - хеш-таблица.  
i-й эл-т массива - односвязный список ключей с хешем равным ``i``
![img.png](img.png)

>- ``find x`` - посчитать хеш ``x``, пройтись по списку
>- ``insert x`` - посчитать хеш ``x``, добавить в начало/конец списка
>- ``erase x`` - посчитать хеш значение, пройтись по списку, найти ``x`` и удалить его

> Общая идея: ``h`` - случайна.
> Т.е. есть H - семейство ф-ий, и мы случайно равновероятно выбираем ``h``

### Универсальные семейства хещ ф-ий
> Опр. Сем-во хеш ф-ий H наз-ся универсальным, если:

![img_1.png](img_1.png)
![img_2.png](img_2.png)

> Теор. Если H - универс. СХФ, то мат. ож. времени обработки всех запросов есть O(1+a), где a = n / m
>  (n - кол-во вставл. ключей)  
> load factor a

![img_3.png](img_3.png)

> Вып. операции как обычно, но если a превышает порог, то делаем rehash:  
> * расширяем таблицу в два раза
> * пересчитываем хеш-функцию
> * перекладываем эл-ты  
> Аморт О(1)*

##### Пример универсального семейства
![img_5.png](img_5.png)
### Совершенное хеширование
> Даны ``a1,...,an`` далее - запросы только с этими ключами.  
> Построим за О(n) такую структуру, что:
>- insert - O(1)
>- erase - O(1)
>- find   - O(1)

Пусть ``hout`` - фикс, а ``ci = |{j: hout(aj) = i}|``  
1) hout нужно выбрать так, чтобы <img alt="img_6.png" height="40" src="img_6.png"/>  
Генерируем hout, пока это условие не выполнится (вероятность 1/2)  
   <img alt="img_7.png" height="300" src="img_7.png"/>
2) Для каждого i построим свою хеш-таблицу размера ``ci^2``
3) Далее подбираю (для каждого i) hi так, чтобы она не давала коллизий.
> Теорема(б/д). Если x1,...,xk - разл. ключи, m = k^2, H - универс сем-во, то 
> <img alt="img_8.png" height="100" src="img_8.png"/>
### Хеш-таблица с открытой адресацией

Массив чисел размера ``m``.  
``h(x)``

>- insert - считаем j = h(x), идем направо в поисках первой свободной клетки (или клетки с tombstone)
>- find   - идем по j, j+1, ... до первой свободной клетки или x
>- erase - find + кладем tombstone
>- делаем rehash

![img_9.png](img_9.png)

> Теорема(б/д) для линейного пробирования ``(runi = (h(x)+i)%m)``. Если семейство H является 5-независимым, то аморт. мат. ож. времени обработки каждого запроса есть О*(1)

Пример 5-ти независимого семейства:

![img_10.png](img_10.png)

##### Квадратичное пробирование
``runi = (h(x) + i^2) % m``

![img_11.png](img_11.png)

> тут они пересекаются по меньшему кол-ву эл-ов

##### Двойное хеширование

![img_12.png](img_12.png)

> Теорема(б/д) Для двойного хеширования достаточно 2-независимости

### Фильтр Блума.
> 1. insert x
> 2. find x
> 3. Позволим себе неправильно отвечать на запросы типа find x (делать false positive) с маленькой вероятностью E

![img_13.png](img_13.png)
![img_14.png](img_14.png)

> 4. можно добавить erase (если insert будет не заменять на 1, а увеличивать, а erase - уменьшать на 1)

![img_15.png](img_15.png)